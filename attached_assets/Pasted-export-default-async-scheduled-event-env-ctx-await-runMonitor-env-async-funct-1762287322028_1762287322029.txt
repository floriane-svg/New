export default {
  async scheduled(event, env, ctx) {
    await runMonitor(env);
  }
};

async function runMonitor(env) {
  const urls = [
    "https://www.quintoandar.com.br/alugar/imovel/ilha-dos-caicaras-lagoa-rio-de-janeiro-rj-brasil/de-500-a-3500-reais/apartamento/kitnet/1-quartos",
    "https://www.quintoandar.com.br/alugar/imovel/leblon-rio-de-janeiro-rj-brasil/de-500-a-3500-reais/apartamento/kitnet/1-quartos"
  ];

  const keyword = "cozy__cardrow-container";
  const botToken = env.TELEGRAM_TOKEN;
  const chatId = env.TELEGRAM_CHAT_ID;

  if (!botToken || !chatId) {
    log("TELEGRAM_TOKEN ou TELEGRAM_CHAT_ID manquant", "error");
    return;
  }

  const telegramApi = `https://api.telegram.org/bot${botToken}/sendMessage`;

  for (const url of urls) {
    try {
      let count = await countKeywordOccurrences(url, keyword);

      // ðŸ” Si 0 trouvÃ©, on retente une fois aprÃ¨s 1.5s
      if (count === 0) {
        log(`0 trouvÃ© sur ${url}, nouvelle tentative dans 1.5s...`, "warn");
        await new Promise(r => setTimeout(r, 1500));
        count = await countKeywordOccurrences(url, keyword);
        log(`DeuxiÃ¨me essai: ${count} occurrences trouvÃ©es sur ${url}`, "info");
      }

      log(`${count} occurrences trouvÃ©es sur ${url}`, "info");

      const isLeblon = url.includes("leblon");
      const shouldAlert = isLeblon ? count >= 5 : count >= 1;

      if (shouldAlert) {
        const text = `ðŸ  Alerte ${isLeblon ? "Leblon (â‰¥ 5 annonces)" : "Ilha dos CaiÃ§aras"} :\n${url}\nAnnonces dÃ©tectÃ©es : ${count}`;
        await safeFetch(telegramApi, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ chat_id: chatId, text })
        });
        log(`Message Telegram envoyÃ© pour ${url}`, "info");
      }
    } catch (err) {
      log(`Erreur sur ${url}: ${err.message}`, "error");
    }
  }
}

async function countKeywordOccurrences(url, keyword) {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), 8000); // 8s timeout

  // ðŸŽ­ Liste de User-Agents diffÃ©rents
  const userAgents = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 13_4) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Safari/605.1.15",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148"
  ];
  const randomUA = userAgents[Math.floor(Math.random() * userAgents.length)];

  const res = await safeFetch(url, {
    headers: {
      "User-Agent": randomUA,
      "Cache-Control": "no-cache"
    },
    signal: controller.signal
  });

  clearTimeout(timeout);

  if (!res.ok) throw new Error(`HTTP ${res.status}`);

  const html = await res.text();
  return html.toLowerCase().split(keyword.toLowerCase()).length - 1;
}

async function safeFetch(url, options, retries = 2) {
  for (let i = 0; i <= retries; i++) {
    try {
      return await fetch(url, options);
    } catch (err) {
      if (i === retries) throw err;
      log(`Retry ${i + 1} pour ${url} aprÃ¨s erreur: ${err.message}`, "warn");
      await new Promise(r => setTimeout(r, 1000)); // attendre 1s
    }
  }
}

function log(message, level = "info") {
  console[level](`[monitor] ${message}`);
}